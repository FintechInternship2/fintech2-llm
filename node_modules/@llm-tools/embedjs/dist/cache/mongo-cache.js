import createDebugMessages from 'debug';
import { MongoClient } from 'mongodb';
export class MongoCache {
    constructor({ uri, dbName, collectionName }) {
        Object.defineProperty(this, "debug", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: createDebugMessages('embedjs:cache:MongoCache')
        });
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dbName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.uri = uri;
        this.dbName = dbName;
        this.collectionName = collectionName;
    }
    async init() {
        const client = new MongoClient(this.uri);
        await client.connect();
        // Create index on loaderId field
        this.collection = client.db(this.dbName).collection(this.collectionName);
        try {
            await this.collection.createIndex({ loaderId: 1 }, { unique: true });
        }
        catch {
            this.debug('Index on loaderId already exists.');
        }
    }
    async addLoader(loaderId, chunkCount) {
        await this.collection.insertOne({ loaderId, chunkCount });
    }
    async getLoader(loaderId) {
        const result = await this.collection.findOne({ loaderId });
        return { chunkCount: result ? result.chunkCount : 0 }; // Assuming a default value of 0 if result is null
    }
    async hasLoader(loaderId) {
        return !!(await this.collection.findOne({ loaderId }));
    }
    async loaderCustomSet(loaderCombinedId, value) {
        const result = await this.collection.updateOne({ loaderId: loaderCombinedId }, { $setOnInsert: { loaderId: loaderCombinedId, value } }, { upsert: false });
        if (result.matchedCount === 0) {
            await this.collection.insertOne({ loaderId: loaderCombinedId, value });
        }
    }
    async loaderCustomGet(loaderCombinedId) {
        const result = await this.collection.findOne({ loaderId: loaderCombinedId });
        return result?.value;
    }
    async loaderCustomHas(loaderCombinedId) {
        return !!(await this.collection.findOne({ loaderId: loaderCombinedId }));
    }
    async clear() {
        await this.collection.deleteMany({});
    }
    async deleteLoader(loaderId) {
        await this.collection.deleteOne({ loaderId });
    }
    async loaderCustomDelete(loaderCombinedId) {
        await this.collection.deleteOne({ loaderId: loaderCombinedId });
    }
}
